# 完整检测代码说明

## 系统设计原理

本系统采用**分层追踪**架构：
- **只对 class0（storage box）进行SORT追踪**
- **对其他class（class1-class9）只检测是否出现在class0框内，不进行独立追踪**

## 检测流程详解

### 整体架构图

```
输入帧
  ↓
[YOLO检测器]
  ├─ 检测所有class目标 (class0-class9)
  ↓
[按类别拆分]
  ├─ class0: storage box
  └─ class1-9: 零部件
  ↓
[SORT追踪器] ← 只追踪class0
  ├─ 输入: class0检测结果
  ├─ 输出: 追踪到的class0框 + ID
  ↓
[物品分配] ← 不追踪class1-9，只检查范围
  ├─ 输入: 追踪到的class0框 + class1-9检测结果
  ├─ 逻辑: 检查每个class1-9是否在class0框内
  ├─ 输出: 分配情况 {track_id: {class1: n, class2: m, ...}}
  ↓
[库存管理]
  ├─ 更新装配状态
  ├─ 检查是否完成配置
  └─ 触发报警（缺失件）
  ↓
输出帧 + 报警
```

## 关键代码模块

### 1. DetectionManager（检测管理）

**文件**: `core/detection.py`

#### 函数：`process_frame(frame, confidence_threshold)`

```python
def process_frame(self, frame, confidence_threshold=None):
    """进行目标检测并进行置信度过滤"""
    # 1. 使用YOLO检测整个帧
    results = self.model.predict(source=frame, verbose=False)
    boxes = results[0].boxes
    
    # 2. 过滤低置信度框，并应用忽略区域过滤
    filtered_boxes = []
    for box in boxes:
        if box.conf[0] > confidence_threshold:
            x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
            if not self.is_in_ignored(x1, y1, x2, y2):
                filtered_boxes.append(box)
    
    return frame, filtered_boxes
```

**关键点**：
- 检测所有class（0-9）
- 根据置信度和忽略区域过滤
- 返回原始检测结果（包含class信息）

---

#### 函数：`split_by_class(filtered_boxes)`

```python
def split_by_class(self, filtered_boxes):
    """按类别拆分检测结果"""
    by_class = defaultdict(list)
    for box in filtered_boxes:
        cls_id = int(box.cls[0])
        by_class[cls_id].append(box)
    return by_class
```

**作用**：将混合检测结果按class分类，便于后续分别处理

**输出格式**:
```python
{
    0: [box1, box2, ...],     # storage box
    1: [box3, box4],          # class1 items
    2: [box5],                # class2 items
    ...
}
```

---

#### 函数：`get_detections_for_tracking(filtered_boxes, target_class=0)`

```python
def get_detections_for_tracking(self, filtered_boxes, target_class=0):
    """将YOLO检测结果转换为SORT追踪格式（只提取指定class）"""
    detections = []
    for box in filtered_boxes:
        if int(box.cls[0]) == target_class:
            x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
            confidence = box.conf[0].cpu().numpy()
            detections.append([x1, y1, x2, y2, confidence])
    
    if len(detections) > 0:
        return np.array(detections)  # N x 5
    else:
        return np.empty((0, 5))
```

**作用**：提取class0检测结果，转换为SORT需要的格式

**输出格式**: `[x1, y1, x2, y2, confidence]`

---

#### 函数：`assign_items_to_boxes(class0_boxes_xyxy, items_xyxycls, debug=False)`

```python
@staticmethod
def assign_items_to_boxes(class0_boxes_xyxy, items_xyxycls, debug=False):
    """将非class0物品分配到包含其中心点的class0框中
    
    参数:
      class0_boxes_xyxy: ndarray N x 4 (x1,y1,x2,y2) - 追踪到的storage box
      items_xyxycls: ndarray M x 6 (x1,y1,x2,y2,score,cls) - 检测到的物品
      debug: 是否输出调试信息
    
    返回:
      dict box_index -> list of item rows
    """
    assign = defaultdict(list)
    
    # 遍历每个追踪到的class0框
    for i, b in enumerate(class0_boxes_xyxy):
        x1, y1, x2, y2 = b
        
        # 检查每个物品是否在该框内
        for row in items_xyxycls:
            ix1, iy1, ix2, iy2, score, cls_id = row
            
            # 计算物品中心点
            item_cx = (ix1 + ix2) / 2.0
            item_cy = (iy1 + iy2) / 2.0
            
            # 判断中心点是否在class0框内
            if item_cx >= x1 and item_cx <= x2 and item_cy >= y1 and item_cy <= y2:
                assign[i].append(row)  # 分配到该框
    
    return assign
```

**核心算法**：
1. 对每个追踪到的class0框
2. 检查每个检测到的物品
3. 如果物品中心点在class0框内，则分配给该框
4. 返回分配结果

**输出格式**:
```python
{
    0: [item1, item2, ...],  # class0框0内的物品
    1: [item3, item4],       # class0框1内的物品
    ...
}
```

**物品格式**: `[x1, y1, x2, y2, score, cls_id]`

---

### 2. TrackerManager（追踪管理）

**文件**: `core/tracker.py`

只对class0进行SORT追踪，输入来自 `get_detections_for_tracking()`

```python
tracked_boxes, disappeared_ids = self.tracker_manager.update_tracks(
    class0_detections, target_class=0
)
```

**输出格式**:
- `tracked_boxes`: `[x1, y1, x2, y2, track_id]` (N x 5)
- `disappeared_ids`: 消失的track_id列表

---

### 3. FrameProcessor（帧处理）

**文件**: `modules/frame_processor.py`

#### 函数：`process_frame(frame, visualize=True, debug=False)`

这是整个检测流程的主入口。

```python
def process_frame(self, frame, visualize=True, debug=False):
    """完整的帧处理流程"""
    
    # 第一步：YOLO检测
    annotated_frame, filtered_boxes = self.detection_manager.process_frame(frame)
    
    # 第二步：按类别拆分
    by_class = self.detection_manager.split_by_class(filtered_boxes)
    
    # 第三步：提取class0用于追踪
    class0_nd = self.detection_manager.get_detections_for_tracking(
        by_class.get(0, []), target_class=0
    )
    
    # 第四步：SORT追踪（只追踪class0）
    tracked_boxes, disappeared_ids = self.tracker_manager.update_tracks(
        class0_nd, target_class=0
    )
    
    # 第五步：收集class1-9
    others_list = []
    for cls_id, lst in by_class.items():
        if cls_id == 0:  # 跳过class0，只收集class1-9
            continue
        others_list.extend(lst)
    others_nd = self.detection_manager.boxes_to_ndarray(others_list)
    
    # 第六步：关键：将物品分配到class0框
    # 【这里不对class1-9进行追踪，只检查是否在class0框内】
    if tracked_boxes.size > 0 and others_nd.size > 0:
        assign = self.detection_manager.assign_items_to_boxes(
            tracked_boxes[:, :4],  # class0追踪框
            others_nd,              # class1-9检测结果
            debug=debug
        )
        
        # 第七步：为每个class0计数物品
        for idx, rows in assign.items():
            counts = {}
            for r in rows:
                cls_id = int(r[5])
                if 1 <= cls_id <= 9:
                    key = f'class{cls_id}'
                    counts[key] = counts.get(key, 0) + 1
            items_assign[int(tracked_boxes[idx, 4])] = Counter(counts)
    
    # 第八步：更新库存管理器
    self.inventory.update_for_frame(tracked_boxes, items_assign)
    
    # 第九步：处理消失报警
    alerts, disappearance_status = self.inventory.handle_disappearance(disappeared_ids)
    
    return annotated_frame, tracked_boxes, alerts
```

**关键特点**：
- ✓ class0：追踪
- ✗ class1-9：不追踪，只检查范围内是否出现

---

### 4. InventoryManager（库存管理）

**文件**: `modules/inventory.py`

```python
def update_for_frame(self, tracked_boxes, items_by_track):
    """更新每个tracked box的物品计数
    
    参数:
      tracked_boxes: 本帧追踪到的class0框
      items_by_track: {track_id: Counter({'class1': n, ...})}
    """
    for track_id, frame_counts in items_by_track.items():
        # 检查this_frame_count >= required_quantity
        for class_key, required_qty in self.required.items():
            have = frame_counts.get(class_key, 0)
            if have >= required_qty:
                self.state[track_id]['completed'][class_key] = True
```

---

## 调试技巧

### 启用详细日志

在启动检测时，传递调试参数：

```
http://localhost:5000/start_detection?debug=true
```

或在 Web 界面添加调试按钮。

### 调试模式输出示例

```
======================================================================
[帧处理] 开始处理帧
  检测到的目标总数: 15
  class0: 2 个目标
  class1: 3 个目标
  class2: 1 个目标
  class3: 2 个目标
  ...

[class0 追踪] 准备追踪class0 (storage box)
  本帧class0检测数: 2
  追踪到的class0数: 2
    track_id=5: 框=(100,50,400,300)
    track_id=8: 框=(500,100,800,400)

[物品分配] 准备分配物品到class0框
  待分配的物品总数: 9 (class1-class9)

  框 0: 位置=(100,50,400,300) 大小=300x250
    ✓ class1: 中心(150,100) 置信度=0.92
    ✓ class2: 中心(200,150) 置信度=0.88
    ✗ class3: 中心(450,150) 在框外
  
  track_id=5: 计数结果={'class1': 1, 'class2': 1}

  框 1: 位置=(500,100,800,400) 大小=300x300
    ✓ class3: 中心(600,200) 置信度=0.85
    ✓ class4: 中心(700,250) 置信度=0.90
  
  track_id=8: 计数结果={'class3': 1, 'class4': 1}

[分配结果] 总共分配了 4 个物品

======================================================================
```

### 检查关键点

1. **是否检测到class0？**
   ```
   [class0 追踪] 本帧class0检测数: X
   ```
   如果为0，检查YOLO模型和置信度

2. **是否正确追踪class0？**
   ```
   追踪到的class0数: X
   track_id=5: 框=(...)
   ```

3. **物品是否在框内？**
   ```
   ✓ class1: 中心(150,100) 置信度=0.92
   ✗ class3: 中心(450,150) 在框外
   ```
   看中心点坐标是否在框的范围内

4. **计数结果是否正确？**
   ```
   track_id=5: 计数结果={'class1': 1, 'class2': 1}
   ```

---

## 常见问题

### Q1: 检测到了物品，但没有计数

**排查步骤**:
1. 启用调试模式
2. 查看日志中"✗ 在框外"的数量
3. 如果太多在框外，可能是：
   - 中心点计算不正确（通常不是，因为算法简单）
   - class0框太小（需要调整模型或数据标注）
   - 物品不在配置中（检查 Configuration.json）

### Q2: 某个class的物品从不计数

**排查**:
1. 检查 Configuration.json 中是否包含该class
2. 确认该class的 quantity > 0
3. 启用调试模式，查看是否检测到该class

### Q3: 多个class0时，物品分配混乱

**原因**:
- 物品可能在多个class0框的边界
- 当前算法是"一对多"分配（物品只能分配给包含其中心点的class0）

**改进方案**:
如果物品边界重叠，可以改用面积重叠率判断（需要修改 `assign_items_to_boxes`）

---

## 修改代码的最佳实践

### 修改分配逻辑

如果要改变"中心点判断"为其他方式，编辑：

```python
# core/detection.py - assign_items_to_boxes()

# 当前逻辑：中心点在框内
if item_cx >= x1 and item_cx <= x2 and item_cy >= y1 and item_cy <= y2:
    assign[i].append(row)

# 改为：面积重叠率 > 50%
from detection import iou_batch
iou = iou_batch([ix1, iy1, ix2, iy2], [x1, y1, x2, y2])
if iou > 0.5:
    assign[i].append(row)
```

### 修改追踪参数

在 Web 界面设置：
- `sort_max_age`: SORT追踪器最大年龄
- `sort_min_hits`: 被返回前的最少帧数
- `sort_iou_threshold`: IoU阈值

### 修改检测参数

在 Web 界面设置：
- `conf_threshold`: YOLO置信度阈值
- `imgsz`: YOLO输入尺寸

---

## 性能指标

在调试模式下可以观察：

1. **检测速度**: YOLO inference time
2. **追踪速度**: SORT update time
3. **分配速度**: 通常 < 1ms
4. **总处理时间**: 应该 < 目标FPS的倒数

例如：目标30 FPS = 33ms/帧，总处理时间应该 < 30ms
